/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.Task;

use Runtime.lib;
use Runtime.RuntimeUtils;
use Runtime.Annotations.Entity;
use Runtime.Annotations.IntrospectionClass;
use Runtime.Annotations.IntrospectionInfo;
use Runtime.ORM.Cursor;
use Runtime.ORM.ORMProviderInterface;
use Runtime.Task.CronMethodInfo;
use Runtime.Task.CronTask;
use Runtime.Task.CronTimer;
use Runtime.Task.TaskList;
use Runtime.Task.TaskMethod;
use Runtime.Task.TaskOutputProvider;


class TaskLib
{
	
	/**
	 * Returns task methods
	 */
	pure Collection<string> getTaskMethods()
	{
		Vector<string> items = new Vector();
		Collection<TaskList> task_lists = @.entities.filter( lib::isInstance(classof TaskList) );
		for (int i=0; i<task_lists.count(); i++)
		{
			TaskList task_list = task_lists.item(i);
			string class_name = task_list.className();
			
			Collection<string> methods = RuntimeUtils::getMethodsIntrospection
			(
				class_name, [ classof TaskMethod ]
			);
			
			for (int j=0; j<methods.count(); j++)
			{
				items.push(class_name ~ "::" ~ methods.item(j));
			}
		}
		return items;
	}
	
	
	
	/**
	 * Returns cron methods
	 */
	static async Collection<string> getCronMethods()
	{
		ORMProviderInterface p = @ -> method getProvider(classof ORMProviderInterface);
		Vector<CronMethodInfo> items = new Vector();
		
		/* Get methods from annotations */
		Collection<TaskList> task_lists = @.entities.filter( lib::isInstance(classof TaskList) );
		for (int i=0; i<task_lists.count(); i++)
		{
			TaskList task_list = task_lists.item(i);
			string class_name = task_list.className();
			
			Collection<string> methods = RuntimeUtils::getMethodsIntrospection
			(
				class_name, [ classof CronTask, classof CronTimer ]
			);
			
			for (int j=0; j<methods.count(); j++)
			{
				string method_name = methods.item(j);
				
				IntrospectionInfo info = rtl::method(class_name, "getMethodInfoByName")(method_name);
				
				CronTask task = info.annotations.findItem( lib::isInstance(classof CronTask) );
				CronTask timer = info.annotations.findItem( lib::isInstance(classof CronTimer) );
				
				CronMethodInfo info = new CronMethodInfo
				{
					"class_name": class_name,
					"method_name": method_name,
					"kind": (timer != null) ? CronMethodInfo::KIND_TIMER : CronMethodInfo::KIND_TASK,
					"timer": (timer != null) ? timer.timer : 0,
					"cron": (task != null) ? timer.cron : "",
				}
				
				items.push(info);
			}
		}
		
		
		/* Update last run and next_run */
		Cursor cursor = p
			-> await method query
			(
				"select * from " ~ p.prefix ~ "tasks"
			)
		;
		while (true)
		{
			Dict row = cursor.fetch();
			if (not row) break;
			
			int pos = items.find
			(
				bool (CronMethodInfo info) use (row) => info.command() == row.get("command", "")
			);
			if (pos != -1)
			{
				CronMethodInfo info = items.item(pos);
				info <= last_run <= row.get("last_run", 0);
				info = info::updateNextRun(info);
				items.set(pos, info);
			}
		}		
		cursor.close();
		
		return items.toCollection();
	}
	
	
	
	/**
	 * Update last run
	 */
	static async CronMethodInfo updateLastRun(CronMethodInfo info, int last_run)
	{
		ORMProviderInterface p = @ -> method getProvider(classof ORMProviderInterface);
		Cursor cursor = p
			-> await method query
			(
				"update " ~ p.prefix ~ "tasks set last_run=:last_run where command=:command",
				{
					"command": info.command(),
					"last_run": last_run,
				}
			)
			-> method end
		;
		info <= last_run <= last_run;
		return info;
	}
	
}
